# devops-project1/infra/helm/backend/templates/db-deploy.yaml
{{- /* infra/helm/backend/templates/db-deploy.yaml */ -}}
{{- $db := (.Values.db | default dict) -}}
{{- $dbSecrets := (get $db "secrets" | default dict) -}}
{{- $credsName := (get $dbSecrets "credsName" | default "db-secrets") -}}
{{- if ($db.enabled | default false) }}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: db
  labels:
    app: mario-db
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mario-db
  template:
    metadata:
      labels:
        app: mario-db
    spec:
      securityContext:
        fsGroup: 999
        fsGroupChangePolicy: OnRootMismatch

      # Only fix filesystem perms on the PVC
      initContainers:
        - name: fix-perms
          image: busybox:1.36
          securityContext:
            runAsUser: 0
          command: ["sh","-c"]
          args:
            - |
              set -eux
              mkdir -p /var/lib/postgresql/data /var/lib/postgresql/data/pgdata
              chown -R 999:999 /var/lib/postgresql/data
              chmod 700 /var/lib/postgresql/data/pgdata || true
          volumeMounts:
            - name: data
              mountPath: /var/lib/postgresql/data

      containers:
        - name: postgres
          image: {{ ($db.image | default "postgres:15") | quote }}
          env:
            - name: PGDATA
              value: /var/lib/postgresql/data/pgdata
          envFrom:
            - secretRef:
                name: {{ $credsName | quote }}
          ports:
            - containerPort: 5432
          readinessProbe:
            exec:
              command: ["sh","-lc","pg_isready -U ${POSTGRES_USER:-postgres} -d template1"]
            initialDelaySeconds: 5
            periodSeconds: 5
          livenessProbe:
            exec:
              command: ["sh","-lc","pg_isready -U ${POSTGRES_USER:-postgres} -d template1"]
            initialDelaySeconds: 20
            periodSeconds: 10
          securityContext:
            runAsNonRoot: true
            runAsUser: 999
          volumeMounts:
            - name: data
              mountPath: /var/lib/postgresql/data

          # Create role/db AFTER postgres is up, using template1 and a robust admin selection
          lifecycle:
            postStart:
              exec:
                command:
                  - bash
                  - -lc
                  - |
                    set -euo pipefail

                    # Small helper: try a connection (user, db)
                    try_conn() {
                      local u="$1"; local d="$2"
                      PGPASSWORD="${POSTGRES_PASSWORD:-}" psql -U "$u" -d "$d" -Atc "SELECT 1" >/dev/null 2>&1
                    }

                    # Wait until server socket is ready
                    for i in {1..60}; do
                      if try_conn "${POSTGRES_USER:-postgres}" "template1"; then
                        ADMIN_USER="${POSTGRES_USER:-postgres}"
                        break
                      elif try_conn "postgres" "template1"; then
                        ADMIN_USER="postgres"
                        break
                      fi
                      sleep 2
                    done

                    if [ -z "${ADMIN_USER:-}" ]; then
                      echo "Postgres not ready for admin connection" >&2
                      exit 1
                    fi

                    # Use template1 for admin ops (exists even if 'postgres' db was removed)
                    TARGET_USER="${POSTGRES_USER:-mario}"
                    TARGET_DB="${POSTGRES_DB:-mario}"
                    TARGET_PASS="${POSTGRES_PASSWORD:-}"

                    # Create role if missing (skip if admin is already that role)
                    if [ "$ADMIN_USER" != "$TARGET_USER" ]; then
                      if ! PGPASSWORD="${POSTGRES_PASSWORD:-}" psql -U "$ADMIN_USER" -d template1 -Atc \
                           "SELECT 1 FROM pg_roles WHERE rolname='${TARGET_USER}'" | grep -q 1; then
                        PGPASSWORD="${POSTGRES_PASSWORD:-}" psql -U "$ADMIN_USER" -d template1 -v ON_ERROR_STOP=1 -c \
                          "CREATE USER ${TARGET_USER} WITH PASSWORD '${TARGET_PASS}';"
                      fi
                    else
                      # If admin == target, ensure password is set (idempotent)
                      if [ -n "$TARGET_PASS" ]; then
                        PGPASSWORD="${POSTGRES_PASSWORD:-}" psql -U "$ADMIN_USER" -d template1 -v ON_ERROR_STOP=1 -c \
                          "ALTER USER ${TARGET_USER} WITH PASSWORD '${TARGET_PASS}';"
                      fi
                    fi

                    # Create DB if missing, owned by TARGET_USER
                    if ! PGPASSWORD="${POSTGRES_PASSWORD:-}" psql -U "$ADMIN_USER" -d template1 -Atc \
                         "SELECT 1 FROM pg_database WHERE datname='${TARGET_DB}'" | grep -q 1; then
                      PGPASSWORD="${POSTGRES_PASSWORD:-}" psql -U "$ADMIN_USER" -d template1 -v ON_ERROR_STOP=1 -c \
                        "CREATE DATABASE ${TARGET_DB} OWNER ${TARGET_USER};"
                    fi

      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: pg-data
{{- end }}
